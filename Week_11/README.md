# 学习笔记

## 作业

### 周日

#### ex04 基于 Redis 封装分布式数据操作

* [在 Java 中实现一个简单的分布式锁](distributed-lock-with-redis/src/main/java/com/alex/homework/distributed/lock/redis/support/RedisLockSupport.java)
* [在 Java 中实现一个分布式计数器，模拟减库存。](distributed-counter-with-redis/src/main/java/com/alex/homwork/distributed/counter/support/StockSupport.java)

## 笔记

### 数据从使用频率和方式上的分类

* 按照使用方式
  * 静态数据: 一般不变，类似于字典表
  * 准静态数据： 变化频率很低，比如组织结构，行政区域划分
  * 中间状态数据： 一些计算的课复用中间数据，变量副本，配置中心的本地副本等
* 按照使用频率
  * 热数据： 使用频率高
  * 读写比较大：读的频率 >> 写的频率

结论：这些数据适合使用缓存。如果需要做的是一个低延迟的系统，那么数据离CPU和内存越近越好，离磁盘和I/O 越远越好

### 广义的缓存

内存可以看做是CPU和磁盘之间的缓存。

CPU 与内存的处理速度不一致，出现了 L1, L2 缓存

网络处理，数据库引擎的各种Buffer，可以看做是缓存

GUI 的 Double Buffer是一个经典的性能优化方法

缓存的本质：系统各级处理速度不匹配，导致利用空间换时间。缓存可以说是提升系统性能的一个简单且有效的办法

### 缓存的加载时机

1. 启动全量加载，全局有效，使用简单（缺陷是若全量数据较大，则会引起其他问题)
2. 懒加载
   1. 同步使用加载
      * 先看缓存是否有数据，没有的话从数据库读取
      * 读取的数据，先放到内存，然后返回给调用方
   2. 延迟异步加载
      * 从缓存获取数据，不管是否为空，直接返回
        * 如果为空，则发起一个异步加载的线程，负责加载数据
        * 异步线程负责维护缓存的数据，定期或根据条件出发更新缓存

### 缓存的有效性和数据同步

#### 不适用缓存的场景

变化频率高，一致性要求高的数据，将导致内存与原始数据之间始终存在差异。

而一致性要求高的系统，在这种情况下，只有使用原始数据，甚至加了事务才能保障

结论，变化频率高，一致性要求高的数据，不适合使用缓存来提速

#### 缓存有效性

* 读写比：对数据的写操作导致数据变动，意味着维护成本。N:1(一般要求N >= 10 )
* 命中率：命中缓存意味着缓存数据被使用，缓存的价值高。90%+(最近N次调用中，命中缓存的次数 除以 N )

对于数据一致性，性能，成本的综合考量，是引入缓存的必须指标

### 缓存使用不当导致的问题

1. 系统预热导致启动慢
2. 系统内存资源耗尽(集中在旧数据的处理机制上)

### 本地缓存

#### 最简单的本地缓存

```java
public static final Map<String, Object> CACHE = new HashMap();

CACHE.put("key", "value");

String something = (String) CACHE.get("key");

```

* Hibernate 缓存
* MyBatis 缓存
* Guava 缓存
* Spring Cache

#### 本地缓存的缺陷

1. 集群环境下，多个节点之间的缓存的同步机制导致了缓存的读写放大
2. 长期占用JVM 资源
3. 缓存数据的调度处理，影响了执行业务的线程以及产生了资源竞争

结论：集群环境下的缓存需要集中处理

### 远程缓存

#### 常用 远程缓存中间件

* Memcached
* Redis

### 缓存的未来-内存网格

* Hazelcast
* Ignite

### 缓存的策略

#### 容量

硬件资源有限，所以：

* 缓存数据容量是必须要考虑的问题
* 系统的设计容量，使用容量，峰值，是架构设计的常识

#### 过期策略

* 按照FIFO 或者 LRU
* 安固定时间过期
* 按业务时间加权(3 + 5x)

### 缓存设计的常见问题

#### 缓存穿透

问题: 大量并发查询不存在的Key，导致系统压力直接引导向数据库

解决方案：

1. 缓存空值的 Key,避免影响数据库
2. 使用 Bloom 过滤器 或者 RoaringBitmap 快速判断Key 是否存在
3. 完全以缓存为准，使用延迟异步加载策略。

#### 缓存击穿

问题: 当某个 Key 失效的时候，正好有大量并发请求访问这个Key

解决方法：

1. Key的更新操作添加全局互斥锁
2. 完全已缓存为准，使用延迟异步加载策略(单独线程负责更新缓存)

#### 缓存雪崩

问题：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大而宕机

解决方法：

1. 更新策略在时间维度上做到比较均匀
2. 使用的热数据尽量分散到不同的机器上
3. 多台机器做主从复制或多副本，实现高可用
4. 实现限流熔断机制，对系统的负载能力进行调控

### Redis 的使用场景

#### Redis 作为业务数据缓存

1. 通用数据缓存，string, int, list, map等
2. 实时热数据，最近500条数据
3. 会话缓存， token缓存

#### Redis 作为业务数据处理

1. 非严格一致性要求的数据， 评论，点击等
2. 业务数据去重，订单处理的幂等校验等
3. 业务数据排序，排名，排行榜等

#### Redis 作为全局一致计数

1. 全局流控计数
2. 秒杀的库存计算
3. 抢红包
4. 全局ID生成

#### Redis 高效统计计数

1. id去重，记录访问ip等全局bitmap操作
2. UV, PV 等访问量（非严格一致性)

#### Redis 发布订阅与Stream

1. Pub-Sub 模拟队列
2. Redis Stream 用于消息队列

#### Redis 作为分布式锁

1. 获取锁-单个原子操作

```bash
SET dlock my_random_value NX PX 30000
```

2. 释放锁-使用lua脚本-保证原子性+单线程，从而具有事务性

```lua
if redis.call("get",KEYS[1] == ARGV[1] then)
    return redis.call("del", KEYS[1])
else
    return 0
end
```

### Redis 事务

* 开启事务:multi（开启后，命令入队）
* 执行事务:exec(相当于 commit)
* 撤销事务：discard(相当于 rollback)
* -Watch 实现乐观锁(watch 一个key，发生变化则事务失败)

### Redis 备份与恢复 RDB <-> frm

#### 备份

执行 save 命令，将在 redis 的数据目录生成数据库文件 dump.rdb

也可以异步执行 bgsave

#### 恢复

将备份文移动到 redis 数据目录并启动服务即可

```bash
# 查看文件夹 
CONFIG GET dir
```

### Redis 备份与恢复 AOF <-> binlog

#### 使用 binlog 备份

设置 appendonly 配置为 yes，则以AOF方式备份 Redis 数据

#### AOF 下的数据恢复

自动加载